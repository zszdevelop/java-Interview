# 拖拽排序后端设计思路

## 1. 背景

最近做项目的时候遇到一个问题，就是前端需要对图片材料等拖拽排序。但排序后怎么存储？是批量保存所有顺序

## 2. 需求描述

- 允许更改元素的排序；
- 允许新增数据，并更新现有排序；
- 允许删除数据，并更新现有排序。

## 3. 解决方案

### 3.1 方案一： 全量更新元素位置

- 适用场景：

  排序元素数量较少

- 原理：

  每个元素拥有一个字段，表示元素当前排序的位置。通过前端排序，将排好的元素位置，一次性发送到后端。然后，后端统一更新所有元素的位置。

- 缺点

  数据量过大，会导致频繁修改，造成数据库IO瓶颈

- 总结：

  此方法仅适用于排序元素较少（例如，总元素为5~15个）的场景。对于大量数据排序并不适用

### 3.2 取中值法（推荐）

原理与实现步骤：

1. 创建元素时给元素赋默认位置（`pos`字段记录该值）。赋值规则为，当创建第一个元素时，默认位置赋值为65536，第二个元素为 `2 * 65536 = 13172`，增加第N个元素时，位置赋值为N*65536。
2. 当拖拽改变元素位置时，更新 `pos`。更新规则如下：

- 调整一个元素到两个元素中间时，`(pre_item.pos + after_item.pos）/ 2 = pos`
- 调整一个元素到第一个元素时， `old_first_item.pos / 2 = pos`
- 调整一个元素到最后一个元素时， `old_last_item.post + 65536 = pos`

1. 当前后两个元素的数值，不满足整数时，更新所有元素的排序。依次给每个元素的 `pos`赋新值。例如，第一位赋值65536，第二位为`2 * 65536`，第N位赋值N*65536。

通过取中值的方法，改变元素的位置。当需要按序获取时，只需要对 `pos`进行排序，就可以获取元素的位置。

#### 3.2.1 重排问题方案

- 方案1：浮点数

  可以使用浮点数储存 `pos`，但是需要考虑数据库存储的精度问题。而且，数值过小，会在前端丢失精度，元素排序会出现问题

- 方案2（推荐）：数值过小重排

  如果在接口层，当检测到中值过小，则对所有元素进行重排，接口相应速度会存在问题

- 方案3：定时重排

  利用定时任务每天对所有元素定时重排，来解决单次接口的性能问题。个人觉得这个方法，还是存在问题。若定时任务不及时，那么排序由于精度问题

## 参考文章

[拖拽排序后端设计与实现](https://www.jianshu.com/p/9ee708e43ebf)

